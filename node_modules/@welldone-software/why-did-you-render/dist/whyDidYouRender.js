/**
 * @welldone-software/why-did-you-render 10.0.1
 * MIT Licensed
 * Generated by Vitali Zaidman <vzaidman@gmail.com> (https://github.com/vzaidman)
 * Generated at 2025-01-18
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react'), require('lodash')) :
  typeof define === 'function' && define.amd ? define(['react', 'lodash'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.whyDidYouRender = factory(global.react, global.lodash));
})(this, (function (React, lodash) { 'use strict';

  function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n.default = e;
    return Object.freeze(n);
  }

  var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

  var wdyrStore = {
    /* The React object we patch */
    React: undefined,
    /* Processed user options for WDYR */
    options: undefined,
    /* The original React.createElement function */
    origCreateElement: undefined,
    /* The original React.createFactory function */
    origCreateFactory: undefined,
    /* The original React.cloneElement function */
    origCloneElement: undefined,
    /* A weak map of all React elements to their WDYR patched react elements */
    componentsMap: new WeakMap(),
    /* A weak map of props to the owner element that passed them */
    ownerDataMap: new WeakMap(),
    /* An array of infos for hooks tracked during current render */
    hooksInfoForCurrentRender: new WeakMap(),
    /* Owner before element creation started */
    ownerBeforeElementCreation: null
  };

  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
  }
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _arrayLikeToArray(r);
  }
  function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  function _callSuper(t, o, e) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e, _getPrototypeOf(t).constructor) : o.apply(t, e));
  }
  function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", {
      writable: !1
    }), e;
  }
  function _createForOfIteratorHelper(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {
        t && (r = t);
        var n = 0,
          F = function () {};
        return {
          s: F,
          n: function () {
            return n >= r.length ? {
              done: !0
            } : {
              done: !1,
              value: r[n++]
            };
          },
          e: function (r) {
            throw r;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o,
      a = !0,
      u = !1;
    return {
      s: function () {
        t = t.call(r);
      },
      n: function () {
        var r = t.next();
        return a = r.done, r;
      },
      e: function (r) {
        u = !0, o = r;
      },
      f: function () {
        try {
          a || null == t.return || t.return();
        } finally {
          if (u) throw o;
        }
      }
    };
  }
  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[r] = t, e;
  }
  function _get() {
    return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {
      var p = _superPropBase(e, t);
      if (p) {
        var n = Object.getOwnPropertyDescriptor(p, t);
        return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
      }
    }, _get.apply(null, arguments);
  }
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, _getPrototypeOf(t);
  }
  function _inherits(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t,
        writable: !0,
        configurable: !0
      }
    }), Object.defineProperty(t, "prototype", {
      writable: !1
    }), e && _setPrototypeOf(t, e);
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function () {
      return !!t;
    })();
  }
  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
  }
  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = !0,
        o = !1;
      try {
        if (i = (t = t.call(r)).next, 0 === l) {
          if (Object(t) !== t) return;
          f = !1;
        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
      } catch (r) {
        o = !0, n = r;
      } finally {
        try {
          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r) {
        return Object.getOwnPropertyDescriptor(e, r).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
        _defineProperty(e, r, t[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
      });
    }
    return e;
  }
  function _possibleConstructorReturn(t, e) {
    if (e && ("object" == typeof e || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
      return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
  }
  function _slicedToArray(r, e) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
  }
  function _superPropBase(t, o) {
    for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)););
    return t;
  }
  function _superPropGet(t, o, e, r) {
    var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e);
    return 2 & r && "function" == typeof p ? function (t) {
      return p.apply(e, t);
    } : p;
  }
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _typeof(o) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
  }
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
  }

  var diffTypes = {
    'different': 'different',
    'deepEquals': 'deepEquals',
    'date': 'date',
    'regex': 'regex',
    'reactElement': 'reactElement',
    'function': 'function',
    'same': 'same'
  };
  var diffTypesDescriptions = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, diffTypes.different, 'different objects'), diffTypes.deepEquals, 'different objects that are equal by value'), diffTypes.date, 'different date objects with the same value'), diffTypes.regex, 'different regular expressions with the same value'), diffTypes.reactElement, 'different React elements (remember that the <jsx/> syntax always produces a *NEW* immutable React element so a component that receives <jsx/> as props always re-renders)'), diffTypes["function"], 'different functions with the same name'), diffTypes.same, 'same objects by ref (===)');

  // copied from packages/shared/ReactSymbols.js in https://github.com/facebook/react
  var hasSymbol$1 = typeof Symbol === 'function' && Symbol["for"];
  var REACT_MEMO_TYPE = hasSymbol$1 ? Symbol["for"]('react.memo') : 0xead3;
  var REACT_FORWARD_REF_TYPE = hasSymbol$1 ? Symbol["for"]('react.forward_ref') : 0xead0;
  var REACT_STRICT_MODE = 8;

  var hasElementType = typeof Element !== 'undefined';

  // copied from https://github.com/facebook/react/blob/fc5ef50da8e975a569622d477f1fed54cb8b193d/packages/react-devtools-shared/src/backend/shared/ReactSymbols.js#L26
  var hasSymbol = typeof Symbol === 'function' && Symbol["for"];
  var LEGACY_ELEMENT_NUMBER = 0xeac7;
  var LEGACY_ELEMENT_SYMBOL_STRING = hasSymbol && Symbol["for"]('react.element');
  var ELEMENT_SYMBOL_STRING = hasSymbol && Symbol["for"]('react.transitional.element');
  var isReactElement = function isReactElement(object) {
    return [].concat(_toConsumableArray(hasSymbol ? [ELEMENT_SYMBOL_STRING, LEGACY_ELEMENT_SYMBOL_STRING] : []), [LEGACY_ELEMENT_NUMBER]).includes(object.$$typeof);
  };
  // end

  function trackDiff(a, b, diffsAccumulator, pathString, diffType) {
    diffsAccumulator.push({
      diffType: diffType,
      pathString: pathString,
      prevValue: a,
      nextValue: b
    });
    return diffType !== diffTypes.different;
  }
  function isGetter(obj, prop) {
    return !!Object.getOwnPropertyDescriptor(obj, prop)['get'];
  }
  var dependenciesMap = new WeakMap();
  function accumulateDeepEqualDiffs(a, b, diffsAccumulator) {
    var pathString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
    var _ref = arguments.length > 4 ? arguments[4] : undefined,
      detailed = _ref.detailed;
    if (a === b) {
      if (detailed) {
        trackDiff(a, b, diffsAccumulator, pathString, diffTypes.same);
      }
      return true;
    }
    if (!a || !b) {
      return trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);
    }
    if (lodash.isArray(a) && lodash.isArray(b)) {
      var arrayLength = a.length;
      if (arrayLength !== b.length) {
        return trackDiff(_toConsumableArray(a), _toConsumableArray(b), diffsAccumulator, pathString, diffTypes.different);
      }
      var arrayItemDiffs = [];
      var numberOfDeepEqualsItems = 0;
      for (var i = arrayLength; i--; i > 0) {
        var diffEquals = accumulateDeepEqualDiffs(a[i], b[i], arrayItemDiffs, "".concat(pathString, "[").concat(i, "]"), {
          detailed: detailed
        });
        if (diffEquals) {
          numberOfDeepEqualsItems++;
        }
      }
      if (detailed || numberOfDeepEqualsItems !== arrayLength) {
        diffsAccumulator.push.apply(diffsAccumulator, arrayItemDiffs);
      }
      if (numberOfDeepEqualsItems === arrayLength) {
        return trackDiff(_toConsumableArray(a), _toConsumableArray(b), diffsAccumulator, pathString, diffTypes.deepEquals);
      }
      return trackDiff(_toConsumableArray(a), _toConsumableArray(b), diffsAccumulator, pathString, diffTypes.different);
    }
    if (lodash.isSet(a) && lodash.isSet(b)) {
      if (a.size !== b.size) {
        return trackDiff(new Set(a), new Set(b), diffsAccumulator, pathString, diffTypes.different);
      }
      var _iterator = _createForOfIteratorHelper(a),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var valA = _step.value;
          if (!b.has(valA)) {
            return trackDiff(new Set(a), new Set(b), diffsAccumulator, pathString, diffTypes.different);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return trackDiff(new Set(a), new Set(b), diffsAccumulator, pathString, diffTypes.deepEquals);
    }
    if (lodash.isDate(a) && lodash.isDate(b)) {
      return a.getTime() === b.getTime() ? trackDiff(new Date(a), new Date(b), diffsAccumulator, pathString, diffTypes.date) : trackDiff(new Date(a), new Date(b), diffsAccumulator, pathString, diffTypes.different);
    }
    if (lodash.isRegExp(a) && lodash.isRegExp(b)) {
      return a.toString() === b.toString() ? trackDiff(a, b, diffsAccumulator, pathString, diffTypes.regex) : trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);
    }
    if (hasElementType && a instanceof Element && b instanceof Element) {
      return trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);
    }
    if (isReactElement(a) && isReactElement(b)) {
      if (a.type !== b.type) {
        return trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);
      }
      var reactElementPropsAreDeepEqual = accumulateDeepEqualDiffs(a.props, b.props, [], "".concat(pathString, ".props"), {
        detailed: detailed
      });
      return reactElementPropsAreDeepEqual ? trackDiff(a, b, diffsAccumulator, pathString, diffTypes.reactElement) : trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);
    }
    if (lodash.isFunction(a) && lodash.isFunction(b)) {
      if (a.name !== b.name) {
        return trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);
      }
      var aDependenciesObj = dependenciesMap.get(a);
      var bDependenciesObj = dependenciesMap.get(b);
      if (aDependenciesObj && bDependenciesObj) {
        var dependenciesAreDeepEqual = accumulateDeepEqualDiffs(aDependenciesObj.deps, bDependenciesObj.deps, diffsAccumulator, "".concat(pathString, ":parent-hook-").concat(aDependenciesObj.hookName, "-deps"), {
          detailed: detailed
        });
        return dependenciesAreDeepEqual ? trackDiff(a, b, diffsAccumulator, pathString, diffTypes["function"]) : trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);
      }
      return trackDiff(a, b, diffsAccumulator, pathString, diffTypes["function"]);
    }
    if (_typeof(a) === 'object' && _typeof(b) === 'object' && Object.getPrototypeOf(a) === Object.getPrototypeOf(b)) {
      var aKeys = Object.getOwnPropertyNames(a);
      var bKeys = Object.getOwnPropertyNames(b);
      var allKeys = lodash.uniq([].concat(_toConsumableArray(aKeys), _toConsumableArray(bKeys)));
      var clonedA = lodash.isPlainObject(a) ? _objectSpread2({}, a) : a;
      var clonedB = lodash.isPlainObject(b) ? _objectSpread2({}, b) : b;
      if (allKeys.length !== aKeys.length || allKeys.length !== bKeys.length) {
        return trackDiff(clonedA, clonedB, diffsAccumulator, pathString, diffTypes.different);
      }
      var relevantKeys = allKeys.filter(function (key) {
        // do not compare the stack as it differ even though the errors are identical.
        if (key === 'stack' && lodash.isError(a)) {
          return false;
        }

        // getters checking is causing too much problems because of how it's used in js.
        // not only getters can throw errors, they also cause side effects in many cases.
        if (isGetter(a, key)) {
          return false;
        }
        return true;
      });
      var keysLength = relevantKeys.length;
      for (var _i = keysLength; _i--; _i > 0) {
        if (!lodash.has(b, relevantKeys[_i])) {
          return trackDiff(clonedA, clonedB, diffsAccumulator, pathString, diffTypes.different);
        }
      }
      var objectValuesDiffs = [];
      var numberOfDeepEqualsObjectValues = 0;
      for (var _i2 = keysLength; _i2--; _i2 > 0) {
        var key = relevantKeys[_i2];
        var deepEquals = accumulateDeepEqualDiffs(a[key], b[key], objectValuesDiffs, "".concat(pathString, ".").concat(key), {
          detailed: detailed
        });
        if (deepEquals) {
          numberOfDeepEqualsObjectValues++;
        }
      }
      if (detailed || numberOfDeepEqualsObjectValues !== keysLength) {
        diffsAccumulator.push.apply(diffsAccumulator, objectValuesDiffs);
      }
      if (numberOfDeepEqualsObjectValues === keysLength) {
        return trackDiff(clonedA, clonedB, diffsAccumulator, pathString, diffTypes.deepEquals);
      }
      return trackDiff(clonedA, clonedB, diffsAccumulator, pathString, diffTypes.different);
    }
    return trackDiff(a, b, diffsAccumulator, pathString, diffTypes.different);
  }
  function calculateDeepEqualDiffs(a, b, initialPathString) {
    var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
      _ref2$detailed = _ref2.detailed,
      detailed = _ref2$detailed === void 0 ? false : _ref2$detailed;
    try {
      var diffs = [];
      accumulateDeepEqualDiffs(a, b, diffs, initialPathString, {
        detailed: detailed
      });
      return diffs;
    } catch (error) {
      if (error.message && error.message.match(/stack|recursion/i) || error.number === -2146828260) {
        // warn on circular references, don't crash.
        // browsers throw different errors name and messages:
        // chrome/safari: "RangeError", "Maximum call stack size exceeded"
        // firefox: "InternalError", too much recursion"
        // edge: "Error", "Out of stack space"
        // eslint-disable-next-line no-console
        console.warn('Warning: why-did-you-render couldn\'t handle circular references in props.', error.name, error.message);
        return false;
      }
      throw error;
    }
  }

  function printDiff(value1, value2, _ref) {
    var pathString = _ref.pathString,
      consoleLog = _ref.consoleLog;
    var diffs = calculateDeepEqualDiffs(value1, value2, pathString, {
      detailed: true
    });
    var keysLength = Math.max.apply(Math, _toConsumableArray(diffs.map(function (diff) {
      return diff.pathString.length;
    }))) + 2;
    Object.entries(lodash.groupBy(lodash.sortBy(diffs, 'pathString'), 'diffType')).forEach(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
        diffType = _ref3[0],
        diffs = _ref3[1];
      consoleLog("%c".concat(diffTypesDescriptions[diffType], ":"), 'text-decoration: underline; color: blue;');
      diffs.forEach(function (diff) {
        consoleLog("".concat(diff.pathString, ":").padEnd(keysLength, ' '), diff.prevValue);
      });
    });
  }

  var moreInfoUrl = 'http://bit.ly/wdyr02';
  var moreInfoHooksUrl = 'http://bit.ly/wdyr3';
  var inHotReload = false;
  function shouldLog(reason, Component) {
    if (inHotReload) {
      return false;
    }
    if (wdyrStore.options.logOnDifferentValues) {
      return true;
    }
    if (Component.whyDidYouRender && Component.whyDidYouRender.logOnDifferentValues) {
      return true;
    }
    var hasDifferentValues = reason.propsDifferences && reason.propsDifferences.some(function (diff) {
      return diff.diffType === diffTypes.different;
    }) || reason.stateDifferences && reason.stateDifferences.some(function (diff) {
      return diff.diffType === diffTypes.different;
    }) || reason.hookDifferences && reason.hookDifferences.some(function (diff) {
      return diff.diffType === diffTypes.different;
    });
    return !hasDifferentValues;
  }
  function logDifference(_ref) {
    var Component = _ref.Component,
      displayName = _ref.displayName,
      hookName = _ref.hookName,
      prefixMessage = _ref.prefixMessage,
      diffObjType = _ref.diffObjType,
      differences = _ref.differences,
      values = _ref.values;
    if (differences && differences.length > 0) {
      wdyrStore.options.consoleLog(_defineProperty({}, displayName, Component), "".concat(prefixMessage, " of ").concat(diffObjType, " changes:"));
      differences.forEach(function (_ref2) {
        var pathString = _ref2.pathString,
          diffType = _ref2.diffType,
          prevValue = _ref2.prevValue,
          nextValue = _ref2.nextValue;
        function diffFn() {
          printDiff(prevValue, nextValue, {
            pathString: pathString,
            consoleLog: wdyrStore.options.consoleLog
          });
        }
        wdyrStore.options.consoleGroup("%c".concat(diffObjType === 'hook' ? "[hook ".concat(hookName, " result]") : "".concat(diffObjType, "."), "%c").concat(pathString, "%c"), "background-color: ".concat(wdyrStore.options.textBackgroundColor, ";color:").concat(wdyrStore.options.diffNameColor, ";"), "background-color: ".concat(wdyrStore.options.textBackgroundColor, ";color:").concat(wdyrStore.options.diffPathColor, ";"), 'background-color: ${wdyrStore.options.textBackgroundColor};color:default;');
        wdyrStore.options.consoleLog("".concat(diffTypesDescriptions[diffType], ". (more info at ").concat(hookName ? moreInfoHooksUrl : moreInfoUrl, ")"));
        wdyrStore.options.consoleLog(_defineProperty({}, "prev ".concat(pathString), prevValue), '!==', _defineProperty({}, "next ".concat(pathString), nextValue));
        if (diffType === diffTypes.deepEquals) {
          wdyrStore.options.consoleLog({
            'For detailed diff, right click the following fn, save as global, and run: ': diffFn
          });
        }
        wdyrStore.options.consoleGroupEnd();
      });
    } else if (differences) {
      wdyrStore.options.consoleLog(_defineProperty({}, displayName, Component), "".concat(prefixMessage, " the ").concat(diffObjType, " object itself changed but its values are all equal."), diffObjType === 'props' ? 'This could have been avoided by making the component pure, or by preventing its father from re-rendering.' : 'This usually means this component called setState when no changes in its state actually occurred.', "More info at ".concat(moreInfoUrl));
      wdyrStore.options.consoleLog("prev ".concat(diffObjType, ":"), values.prev, ' !== ', values.next, ":next ".concat(diffObjType));
    }
  }
  function defaultNotifier(updateInfo) {
    var Component = updateInfo.Component,
      displayName = updateInfo.displayName,
      hookName = updateInfo.hookName,
      prevOwner = updateInfo.prevOwner,
      nextOwner = updateInfo.nextOwner,
      prevProps = updateInfo.prevProps,
      prevState = updateInfo.prevState,
      prevHookResult = updateInfo.prevHookResult,
      nextProps = updateInfo.nextProps,
      nextState = updateInfo.nextState,
      nextHookResult = updateInfo.nextHookResult,
      reason = updateInfo.reason;
    if (!shouldLog(reason, Component, wdyrStore.options)) {
      return;
    }
    wdyrStore.options.consoleGroup("%c".concat(displayName), "background-color: ".concat(wdyrStore.options.textBackgroundColor, ";color: ").concat(wdyrStore.options.titleColor, ";"));
    var prefixMessage = 'Re-rendered because';
    if (reason.propsDifferences) {
      logDifference({
        Component: Component,
        displayName: displayName,
        prefixMessage: prefixMessage,
        diffObjType: 'props',
        differences: reason.propsDifferences,
        values: {
          prev: prevProps,
          next: nextProps
        }
      });
      prefixMessage = 'And because';
    }
    if (reason.stateDifferences) {
      logDifference({
        Component: Component,
        displayName: displayName,
        prefixMessage: prefixMessage,
        diffObjType: 'state',
        differences: reason.stateDifferences,
        values: {
          prev: prevState,
          next: nextState
        }
      });
    }
    if (reason.hookDifferences) {
      logDifference({
        Component: Component,
        displayName: displayName,
        prefixMessage: prefixMessage,
        diffObjType: 'hook',
        differences: reason.hookDifferences,
        values: {
          prev: prevHookResult,
          next: nextHookResult
        },
        hookName: hookName
      });
    }
    if (reason.propsDifferences && reason.ownerDifferences) {
      var prevOwnerData = wdyrStore.ownerDataMap.get(prevOwner);
      var nextOwnerData = wdyrStore.ownerDataMap.get(nextOwner);
      if (prevOwnerData && nextOwnerData) {
        wdyrStore.options.consoleGroup("Rendered by ".concat(nextOwnerData.displayName));
        var _prefixMessage = 'Re-rendered because';
        if (reason.ownerDifferences.propsDifferences) {
          logDifference({
            Component: nextOwnerData.Component,
            displayName: nextOwnerData.displayName,
            prefixMessage: _prefixMessage,
            diffObjType: 'props',
            differences: reason.ownerDifferences.propsDifferences,
            values: {
              prev: prevOwnerData.props,
              next: nextOwnerData.props
            }
          });
          _prefixMessage = 'And because';
        }
        if (reason.ownerDifferences.stateDifferences) {
          logDifference({
            Component: nextOwnerData.Component,
            displayName: nextOwnerData.displayName,
            prefixMessage: _prefixMessage,
            diffObjType: 'state',
            differences: reason.ownerDifferences.stateDifferences,
            values: {
              prev: prevOwnerData.state,
              next: nextOwnerData.state
            }
          });
        }
        if (reason.ownerDifferences.hookDifferences) {
          reason.ownerDifferences.hookDifferences.forEach(function (_ref3, i) {
            var hookName = _ref3.hookName,
              differences = _ref3.differences;
            return logDifference({
              Component: nextOwnerData.Component,
              displayName: nextOwnerData.displayName,
              prefixMessage: _prefixMessage,
              diffObjType: 'hook',
              differences: differences,
              values: {
                prev: prevOwnerData.hooksInfo[i].result,
                next: nextOwnerData.hooksInfo[i].result
              },
              hookName: hookName
            });
          });
        }
        wdyrStore.options.consoleGroupEnd();
      }
    }
    if (!reason.propsDifferences && !reason.stateDifferences && !reason.hookDifferences) {
      wdyrStore.options.consoleLog(_defineProperty({}, displayName, Component), 'Re-rendered although props and state objects are the same.', 'This usually means there was a call to this.forceUpdate() inside the component.', "more info at ".concat(moreInfoUrl));
    }
    wdyrStore.options.consoleGroupEnd();
  }
  function createDefaultNotifier(hotReloadBufferMs) {
    if (hotReloadBufferMs) {
      if (typeof module !== 'undefined' && module.hot && module.hot.addStatusHandler) {
        module.hot.addStatusHandler(function (status) {
          if (status === 'idle') {
            inHotReload = true;
            setTimeout(function () {
              inHotReload = false;
            }, hotReloadBufferMs);
          }
        });
      }
    }
    return defaultNotifier;
  }

  var emptyFn = function emptyFn() {};
  function normalizeOptions() {
    var userOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var consoleGroup = console.group;
    var consoleGroupEnd = console.groupEnd;
    if (userOptions.collapseGroups) {
      consoleGroup = console.groupCollapsed;
    } else if (userOptions.onlyLogs) {
      consoleGroup = console.log;
      consoleGroupEnd = emptyFn;
    }
    var notifier = userOptions.notifier || createDefaultNotifier('hotReloadBufferMs' in userOptions ? userOptions.hotReloadBufferMs : 500);
    return _objectSpread2({
      include: null,
      exclude: null,
      notifier: notifier,
      onlyLogs: false,
      consoleLog: console.log,
      consoleGroup: consoleGroup,
      consoleGroupEnd: consoleGroupEnd,
      logOnDifferentValues: false,
      logOwnerReasons: true,
      trackHooks: true,
      titleColor: '#058',
      diffNameColor: 'blue',
      diffPathColor: 'red',
      textBackgroundColor: 'white',
      trackExtraHooks: [],
      trackAllPureComponents: false
    }, userOptions);
  }

  function getDisplayName(type) {
    return type.displayName || type.name || type.type && getDisplayName(type.type) || type.render && getDisplayName(type.render) || (lodash.isString(type) ? type : 'Unknown');
  }

  function getDefaultProps(type) {
    return type.defaultProps || type.type && getDefaultProps(type.type) || type.render && getDefaultProps(type.render) || undefined;
  }

  var emptyObject = {};
  function findObjectsDifferences(userPrevObj, userNextObj) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$shallow = _ref.shallow,
      shallow = _ref$shallow === void 0 ? true : _ref$shallow;
    if (userPrevObj === userNextObj) {
      return false;
    }
    if (!shallow) {
      return calculateDeepEqualDiffs(userPrevObj, userNextObj);
    }
    var prevObj = userPrevObj || emptyObject;
    var nextObj = userNextObj || emptyObject;
    var keysOfBothObjects = Object.keys(_objectSpread2(_objectSpread2({}, prevObj), nextObj));
    return lodash.reduce(keysOfBothObjects, function (result, key) {
      var deepEqualDiffs = calculateDeepEqualDiffs(prevObj[key], nextObj[key], key);
      if (deepEqualDiffs) {
        result = [].concat(_toConsumableArray(result), _toConsumableArray(deepEqualDiffs));
      }
      return result;
    }, []);
  }

  function getOwnerDifferences(prevOwner, nextOwner) {
    if (!prevOwner || !nextOwner) {
      return false;
    }
    var prevOwnerData = wdyrStore.ownerDataMap.get(prevOwner);
    var nextOwnerData = wdyrStore.ownerDataMap.get(nextOwner);
    if (!prevOwnerData || !nextOwnerData) {
      return false;
    }
    try {
      // in strict mode a re-render happens twice as opposed to the initial render that happens once.
      var prevOwnerDataHooks = prevOwnerData.hooksInfo.length === nextOwnerData.hooksInfo.length * 2 ? prevOwnerData.hooksInfo.slice(prevOwnerData.hooksInfo.length / 2) : prevOwnerData.hooksInfo;
      var hookDifferences = prevOwnerDataHooks.map(function (_ref, i) {
        var hookName = _ref.hookName,
          result = _ref.result;
        return {
          hookName: hookName,
          differences: findObjectsDifferences(result, nextOwnerData.hooksInfo[i].result, {
            shallow: false
          })
        };
      });
      return {
        propsDifferences: findObjectsDifferences(prevOwnerData.props, nextOwnerData.props),
        stateDifferences: findObjectsDifferences(prevOwnerData.state, nextOwnerData.state),
        hookDifferences: hookDifferences.length > 0 ? hookDifferences : false
      };
    } catch (e) {
      wdyrStore.options.consoleLog('whyDidYouRender error in getOwnerDifferences. Please file a bug at https://github.com/welldone-software/why-did-you-render/issues.', {
        errorInfo: {
          error: e,
          prevOwner: prevOwner,
          nextOwner: nextOwner,
          options: wdyrStore.options
        }
      });
      return false;
    }
  }
  function getUpdateReason(prevOwner, prevProps, prevState, prevHookResult, nextOwner, nextProps, nextState, nextHookResult) {
    return {
      propsDifferences: findObjectsDifferences(prevProps, nextProps),
      stateDifferences: findObjectsDifferences(prevState, nextState),
      hookDifferences: findObjectsDifferences(prevHookResult, nextHookResult, {
        shallow: false
      }),
      ownerDifferences: getOwnerDifferences(prevOwner, nextOwner)
    };
  }
  function getUpdateInfo(_ref2) {
    var Component = _ref2.Component,
      displayName = _ref2.displayName,
      hookName = _ref2.hookName,
      prevOwner = _ref2.prevOwner,
      nextOwner = _ref2.nextOwner,
      prevProps = _ref2.prevProps,
      prevState = _ref2.prevState,
      prevHookResult = _ref2.prevHookResult,
      nextProps = _ref2.nextProps,
      nextState = _ref2.nextState,
      nextHookResult = _ref2.nextHookResult;
    return {
      Component: Component,
      displayName: displayName,
      hookName: hookName,
      prevOwner: prevOwner,
      prevProps: prevProps,
      prevState: prevState,
      prevHookResult: prevHookResult,
      nextOwner: nextOwner,
      nextProps: nextProps,
      nextState: nextState,
      nextHookResult: nextHookResult,
      reason: getUpdateReason(prevOwner, prevProps, prevState, prevHookResult, nextOwner, nextProps, nextState, nextHookResult),
      ownerDataMap: wdyrStore.ownerDataMap
    };
  }

  // copied from https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactTypeOfMode.js

  // based on "findStrictRoot" from https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactStrictModeWarnings.js
  // notice: this is only used for class components. functional components doesn't render twice inside strict mode
  function checkIfInsideAStrictModeTree(reactComponentInstance) {
    var reactInternalFiber = reactComponentInstance && (reactComponentInstance._reactInternalFiber || reactComponentInstance._reactInternals);
    while (reactInternalFiber) {
      if (reactInternalFiber.mode & REACT_STRICT_MODE) {
        return true;
      }
      reactInternalFiber = reactInternalFiber["return"];
    }
    return false;
  }
  function isReactClassComponent(Component) {
    return Component.prototype && !!Component.prototype.isReactComponent;
  }
  function isMemoComponent(Component) {
    return Component.$$typeof === REACT_MEMO_TYPE;
  }
  function isForwardRefComponent(Component) {
    return Component.$$typeof === REACT_FORWARD_REF_TYPE;
  }

  function shouldInclude(displayName) {
    return wdyrStore.options.include && wdyrStore.options.include.length > 0 && wdyrStore.options.include.some(function (regex) {
      return regex.test(displayName);
    });
  }
  function shouldExclude(displayName) {
    return wdyrStore.options.exclude && wdyrStore.options.exclude.length > 0 && wdyrStore.options.exclude.some(function (regex) {
      return regex.test(displayName);
    });
  }
  function shouldTrack(Component, _ref) {
    var isHookChange = _ref.isHookChange;
    var displayName = getDisplayName(Component);
    if (shouldExclude(displayName)) {
      return false;
    }
    if (Component.whyDidYouRender === false) {
      return false;
    }
    if (isHookChange && Component.whyDidYouRender && Component.whyDidYouRender.trackHooks === false) {
      return false;
    }
    return !!(Component.whyDidYouRender || wdyrStore.options.trackAllPureComponents && (Component && Component.prototype instanceof wdyrStore.React.PureComponent || isMemoComponent(Component)) || shouldInclude(displayName));
  }

  function patchClassComponent(ClassComponent, _ref) {
    var displayName = _ref.displayName,
      defaultProps = _ref.defaultProps;
    var WDYRPatchedClassComponent = /*#__PURE__*/function (_ClassComponent) {
      function WDYRPatchedClassComponent(props, context) {
        var _this;
        _classCallCheck(this, WDYRPatchedClassComponent);
        _this = _callSuper(this, WDYRPatchedClassComponent, [props, context]);
        _this._WDYR = {
          renderNumber: 0
        };
        var origRender = _superPropGet((WDYRPatchedClassComponent), "render", _this, 1) || _this.render;

        // this probably means that render is an arrow function or this.render.bind(this) was called on the original class
        var renderIsABindedFunction = origRender !== ClassComponent.prototype.render;
        if (renderIsABindedFunction) {
          _this.render = function () {
            WDYRPatchedClassComponent.prototype.render.apply(_this);
            return origRender();
          };
        }
        return _this;
      }
      _inherits(WDYRPatchedClassComponent, _ClassComponent);
      return _createClass(WDYRPatchedClassComponent, [{
        key: "render",
        value: function render() {
          this._WDYR.renderNumber++;
          if (!('isStrictMode' in this._WDYR)) {
            this._WDYR.isStrictMode = checkIfInsideAStrictModeTree(this);
          }

          // in strict mode- ignore every other render
          if (!(this._WDYR.isStrictMode && this._WDYR.renderNumber % 2 === 1)) {
            if (this._WDYR.prevProps) {
              var updateInfo = getUpdateInfo({
                Component: ClassComponent,
                displayName: displayName,
                prevOwner: this._WDYR.prevOwner,
                prevProps: this._WDYR.prevProps,
                prevState: this._WDYR.prevState,
                nextOwner: wdyrStore.ownerBeforeElementCreation,
                nextProps: this.props,
                nextState: this.state
              });
              wdyrStore.options.notifier(updateInfo);
            }
            this._WDYR.prevOwner = wdyrStore.ownerBeforeElementCreation;
            this._WDYR.prevProps = this.props;
            this._WDYR.prevState = this.state;
          }
          return _superPropGet(WDYRPatchedClassComponent, "render", this, 1) ? _superPropGet(WDYRPatchedClassComponent, "render", this, 3)([]) : null;
        }
      }]);
    }(ClassComponent);
    try {
      WDYRPatchedClassComponent.displayName = displayName;
    } catch (_e) {
      // not crucial if displayName couldn't be set
    }
    WDYRPatchedClassComponent.defaultProps = defaultProps;
    lodash.defaults(WDYRPatchedClassComponent, ClassComponent);
    return WDYRPatchedClassComponent;
  }

  var getFunctionalComponentFromStringComponent = function getFunctionalComponentFromStringComponent(componentTypeStr) {
    return function (props) {
      return wdyrStore.React.createElement(componentTypeStr, props);
    };
  };
  function patchFunctionalOrStrComponent(FunctionalOrStringComponent, _ref) {
    var isPure = _ref.isPure,
      displayName = _ref.displayName,
      defaultProps = _ref.defaultProps;
    var FunctionalComponent = typeof FunctionalOrStringComponent === 'string' ? getFunctionalComponentFromStringComponent(FunctionalOrStringComponent) : FunctionalOrStringComponent;
    function WDYRFunctionalComponent(nextProps, refMaybe) {
      var prevPropsRef = wdyrStore.React.useRef();
      var prevProps = prevPropsRef.current;
      prevPropsRef.current = nextProps;
      var prevOwnerRef = wdyrStore.React.useRef();
      var prevOwner = prevOwnerRef.current;
      var nextOwner = wdyrStore.ownerBeforeElementCreation;
      prevOwnerRef.current = nextOwner;
      if (prevProps) {
        var updateInfo = getUpdateInfo({
          Component: FunctionalComponent,
          displayName: displayName,
          prevOwner: prevOwner,
          nextOwner: nextOwner,
          prevProps: prevProps,
          nextProps: nextProps
        });
        var notifiedByHooks = !updateInfo.reason.propsDifferences || isPure && updateInfo.reason.propsDifferences.length === 0;
        if (!notifiedByHooks) {
          wdyrStore.options.notifier(updateInfo);
        }
      }
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      return FunctionalComponent.apply(void 0, [nextProps, refMaybe].concat(args));
    }
    try {
      WDYRFunctionalComponent.displayName = displayName;
    } catch (_e) {
      // not crucial if displayName couldn't be set
    }
    WDYRFunctionalComponent.defaultProps = defaultProps;
    WDYRFunctionalComponent.ComponentForHooksTracking = FunctionalComponent;
    lodash.defaults(WDYRFunctionalComponent, FunctionalComponent);
    return WDYRFunctionalComponent;
  }

  function patchMemoComponent(MemoComponent, _ref) {
    var displayName = _ref.displayName,
      defaultProps = _ref.defaultProps;
    var InnerMemoComponent = MemoComponent.type;
    var isInnerMemoComponentAClassComponent = isReactClassComponent(InnerMemoComponent);
    var isInnerMemoComponentForwardRefs = isForwardRefComponent(InnerMemoComponent);
    var isInnerMemoComponentAnotherMemoComponent = isMemoComponent(InnerMemoComponent);
    var WrappedFunctionalComponent = isInnerMemoComponentForwardRefs ? InnerMemoComponent.render : InnerMemoComponent;
    var PatchedInnerComponent = isInnerMemoComponentAClassComponent ? patchClassComponent(WrappedFunctionalComponent, {
      displayName: displayName,
      defaultProps: defaultProps
    }) : isInnerMemoComponentAnotherMemoComponent ? patchMemoComponent(WrappedFunctionalComponent, {
      displayName: displayName,
      defaultProps: defaultProps
    }) : patchFunctionalOrStrComponent(WrappedFunctionalComponent, {
      displayName: displayName,
      isPure: true
    });
    try {
      PatchedInnerComponent.displayName = getDisplayName(WrappedFunctionalComponent);
    } catch (_e) {
      // not crucial if displayName couldn't be set
    }
    PatchedInnerComponent.ComponentForHooksTracking = MemoComponent;
    lodash.defaults(PatchedInnerComponent, WrappedFunctionalComponent);
    var WDYRMemoizedFunctionalComponent = wdyrStore.React.memo(isInnerMemoComponentForwardRefs ? wdyrStore.React.forwardRef(PatchedInnerComponent) : PatchedInnerComponent, MemoComponent.compare);
    try {
      WDYRMemoizedFunctionalComponent.displayName = displayName;
    } catch (_e) {
      // not crucial if displayName couldn't be set
    }
    WDYRMemoizedFunctionalComponent.defaultProps = defaultProps;
    lodash.defaults(WDYRMemoizedFunctionalComponent, MemoComponent);
    return WDYRMemoizedFunctionalComponent;
  }

  function patchForwardRefComponent(ForwardRefComponent, _ref) {
    var displayName = _ref.displayName,
      defaultProps = _ref.defaultProps;
    var InnerForwardRefComponent = ForwardRefComponent.render;
    var isInnerComponentMemoized = isMemoComponent(InnerForwardRefComponent);
    var WrappedFunctionalComponent = isInnerComponentMemoized ? InnerForwardRefComponent.type : InnerForwardRefComponent;
    var WDYRWrappedByReactForwardRefFunctionalComponent = patchFunctionalOrStrComponent(WrappedFunctionalComponent, {
      isPure: isInnerComponentMemoized,
      displayName: displayName
    });
    WDYRWrappedByReactForwardRefFunctionalComponent.displayName = getDisplayName(WrappedFunctionalComponent);
    WDYRWrappedByReactForwardRefFunctionalComponent.ComponentForHooksTracking = WrappedFunctionalComponent;
    lodash.defaults(WDYRWrappedByReactForwardRefFunctionalComponent, WrappedFunctionalComponent);
    var WDYRForwardRefFunctionalComponent = wdyrStore.React.forwardRef(isInnerComponentMemoized ? wdyrStore.React.memo(WDYRWrappedByReactForwardRefFunctionalComponent, InnerForwardRefComponent.compare) : WDYRWrappedByReactForwardRefFunctionalComponent);
    try {
      WDYRForwardRefFunctionalComponent.displayName = displayName;
    } catch (_e) {
      // not crucial if displayName couldn't be set
    }
    WDYRForwardRefFunctionalComponent.defaultProps = defaultProps;
    lodash.defaults(WDYRForwardRefFunctionalComponent, ForwardRefComponent);
    return WDYRForwardRefFunctionalComponent;
  }

  function getCurrentOwner() {
    var reactSharedInternals = wdyrStore.React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    var reactDispatcher = reactSharedInternals === null || reactSharedInternals === void 0 ? void 0 : reactSharedInternals.A;
    return reactDispatcher === null || reactDispatcher === void 0 ? void 0 : reactDispatcher.getOwner();
  }

  var initialHookValue = Symbol('initial-hook-value');
  function trackHookChanges(hookName, _ref, rawHookResult) {
    var pathToGetTrackedHookResult = _ref.path;
    var nextResult = pathToGetTrackedHookResult ? lodash.get(rawHookResult, pathToGetTrackedHookResult) : rawHookResult;
    var prevResultRef = wdyrStore.React.useRef(initialHookValue);
    var prevResult = prevResultRef.current;
    prevResultRef.current = nextResult;
    var ownerInstance = getCurrentOwner();
    if (!ownerInstance) {
      return rawHookResult;
    }
    if (!wdyrStore.hooksInfoForCurrentRender.has(ownerInstance)) {
      wdyrStore.hooksInfoForCurrentRender.set(ownerInstance, []);
    }
    var hooksInfoForCurrentRender = wdyrStore.hooksInfoForCurrentRender.get(ownerInstance);
    hooksInfoForCurrentRender.push({
      hookName: hookName,
      result: nextResult
    });
    var Component = ownerInstance.type.ComponentForHooksTracking || ownerInstance.type;
    var displayName = getDisplayName(Component);
    var isShouldTrack = shouldTrack(Component, {
      isHookChange: true
    });
    if (isShouldTrack && prevResult !== initialHookValue) {
      var updateInfo = getUpdateInfo({
        Component: Component,
        displayName: displayName,
        hookName: hookName,
        prevHookResult: prevResult,
        nextHookResult: nextResult
      });
      if (updateInfo.reason.hookDifferences) {
        wdyrStore.options.notifier(updateInfo);
      }
    }
    return rawHookResult;
  }
  function createPatchedComponent(Component, _ref2) {
    var displayName = _ref2.displayName,
      defaultProps = _ref2.defaultProps;
    if (isMemoComponent(Component)) {
      return patchMemoComponent(Component, {
        displayName: displayName,
        defaultProps: defaultProps
      });
    }
    if (isForwardRefComponent(Component)) {
      return patchForwardRefComponent(Component, {
        displayName: displayName,
        defaultProps: defaultProps
      });
    }
    if (isReactClassComponent(Component)) {
      return patchClassComponent(Component, {
        displayName: displayName,
        defaultProps: defaultProps
      });
    }
    return patchFunctionalOrStrComponent(Component, {
      displayName: displayName,
      defaultProps: defaultProps,
      isPure: false
    });
  }
  function getPatchedComponent(Component, _ref3) {
    var displayName = _ref3.displayName,
      defaultProps = _ref3.defaultProps;
    if (wdyrStore.componentsMap.has(Component)) {
      return wdyrStore.componentsMap.get(Component);
    }
    var WDYRPatchedComponent = createPatchedComponent(Component, {
      displayName: displayName,
      defaultProps: defaultProps
    });
    wdyrStore.componentsMap.set(Component, WDYRPatchedComponent);
    return WDYRPatchedComponent;
  }
  function getIsSupportedComponentType(Comp) {
    if (!Comp) {
      return false;
    }
    if (isMemoComponent(Comp)) {
      return getIsSupportedComponentType(Comp.type);
    }
    if (isForwardRefComponent(Comp)) {
      return getIsSupportedComponentType(Comp.render);
    }
    if (typeof Comp === 'function') {
      return true;
    }
  }
  var hooksConfig = {
    useState: {
      path: '0'
    },
    useReducer: {
      path: '0'
    },
    useContext: undefined,
    useSyncExternalStore: undefined,
    useMemo: {
      dependenciesPath: '1',
      dontReport: true
    },
    useCallback: {
      dependenciesPath: '1',
      dontReport: true
    }
  };
  function storeOwnerData(element) {
    var owner = getCurrentOwner();
    if (owner) {
      var Component = owner.type.ComponentForHooksTracking || owner.type;
      var displayName = getDisplayName(Component);
      var additionalOwnerData = {};
      if (wdyrStore.options.getAdditionalOwnerData) {
        additionalOwnerData = wdyrStore.options.getAdditionalOwnerData(element);
      }
      wdyrStore.ownerDataMap.set(owner, {
        Component: Component,
        displayName: displayName,
        props: owner.pendingProps,
        state: owner.stateNode ? owner.stateNode.state : null,
        hooksInfo: wdyrStore.hooksInfoForCurrentRender.get(owner) || [],
        additionalOwnerData: additionalOwnerData
      });
      wdyrStore.hooksInfoForCurrentRender["delete"](owner);
    }
  }
  function trackHooksIfNeeded() {
    var hooksSupported = !!wdyrStore.React.useState;
    if (wdyrStore.options.trackHooks && hooksSupported) {
      var nativeHooks = Object.entries(hooksConfig).map(function (_ref4) {
        var _ref5 = _slicedToArray(_ref4, 2),
          hookName = _ref5[0],
          hookTrackingConfig = _ref5[1];
        return [wdyrStore.React, hookName, hookTrackingConfig];
      });
      var hooksToTrack = [].concat(_toConsumableArray(nativeHooks), _toConsumableArray(wdyrStore.options.trackExtraHooks));
      hooksToTrack.forEach(function (_ref6) {
        var _ref7 = _slicedToArray(_ref6, 3),
          hookParent = _ref7[0],
          hookName = _ref7[1],
          _ref7$ = _ref7[2],
          hookTrackingConfig = _ref7$ === void 0 ? {} : _ref7$;
        var originalHook = hookParent[hookName];
        var newHook = function useWhyDidYouRenderReWrittenHook() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var hookResult = originalHook.call.apply(originalHook, [this].concat(args));
          var dependenciesPath = hookTrackingConfig.dependenciesPath,
            dontReport = hookTrackingConfig.dontReport;
          var shouldTrackHookChanges = !dontReport;
          if (dependenciesPath && lodash.isFunction(hookResult)) {
            dependenciesMap.set(hookResult, {
              hookName: hookName,
              deps: lodash.get(args, dependenciesPath)
            });
          }
          if (shouldTrackHookChanges) {
            trackHookChanges(hookName, hookTrackingConfig, hookResult);
          }
          return hookResult;
        };
        Object.defineProperty(newHook, 'name', {
          value: hookName + 'WDYR',
          writable: false
        });
        Object.assign(newHook, {
          originalHook: originalHook
        });
        hookParent[hookName] = newHook;
      });
    }
  }
  function getWDYRType(origType) {
    var isShouldTrack = getIsSupportedComponentType(origType) && shouldTrack(origType, {
      isHookChange: false
    });
    if (!isShouldTrack) {
      return null;
    }
    var displayName = origType && origType.whyDidYouRender && origType.whyDidYouRender.customName || getDisplayName(origType);
    var defaultProps = getDefaultProps(origType);
    var WDYRPatchedComponent = getPatchedComponent(origType, {
      displayName: displayName,
      defaultProps: defaultProps
    });
    return WDYRPatchedComponent;
  }
  function whyDidYouRender(React, userOptions) {
    if (React.__IS_WDYR__) {
      return;
    }
    React.__IS_WDYR__ = true;
    Object.assign(wdyrStore, {
      React: React,
      options: normalizeOptions(userOptions),
      origCreateElement: React.createElement,
      origCreateFactory: React.createFactory,
      origCloneElement: React.cloneElement,
      componentsMap: new WeakMap()
    });
    React.createElement = function (origType) {
      var WDYRType = getWDYRType(origType);
      for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        rest[_key2 - 1] = arguments[_key2];
      }
      if (WDYRType) {
        try {
          wdyrStore.ownerBeforeElementCreation = getCurrentOwner();
          var element = wdyrStore.origCreateElement.apply(React, [WDYRType].concat(rest));
          if (wdyrStore.options.logOwnerReasons) {
            storeOwnerData(element);
          }
          return element;
        } catch (e) {
          wdyrStore.options.consoleLog('whyDidYouRender error in createElement. Please file a bug at https://github.com/welldone-software/why-did-you-render/issues.', {
            errorInfo: {
              error: e,
              componentNameOrComponent: origType,
              rest: rest,
              options: wdyrStore.options
            }
          });
        }
      }
      return wdyrStore.origCreateElement.apply(React, [origType].concat(rest));
    };
    Object.assign(React.createElement, wdyrStore.origCreateElement);
    React.createFactory = function (type) {
      var factory = React.createElement.bind(null, type);
      factory.type = type;
      return factory;
    };
    Object.assign(React.createFactory, wdyrStore.origCreateFactory);
    React.cloneElement = function () {
      wdyrStore.ownerBeforeElementCreation = getCurrentOwner();
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      var element = wdyrStore.origCloneElement.apply(React, args);
      if (wdyrStore.options.logOwnerReasons) {
        storeOwnerData(element);
      }
      return element;
    };
    Object.assign(React.cloneElement, wdyrStore.origCloneElement);
    trackHooksIfNeeded();
    React.__REVERT_WHY_DID_YOU_RENDER__ = function () {
      Object.assign(React, {
        createElement: wdyrStore.origCreateElement,
        createFactory: wdyrStore.origCreateFactory,
        cloneElement: wdyrStore.origCloneElement
      });
      wdyrStore.componentsMap = null;
      var hooksToRevert = [].concat(_toConsumableArray(Object.keys(hooksConfig).map(function (hookName) {
        return [React, hookName];
      })), _toConsumableArray(wdyrStore.options.trackExtraHooks));
      hooksToRevert.forEach(function (_ref8) {
        var _ref9 = _slicedToArray(_ref8, 2),
          hookParent = _ref9[0],
          hookName = _ref9[1];
        if (hookParent[hookName].originalHook) {
          hookParent[hookName] = hookParent[hookName].originalHook;
        }
      });
      delete React.__REVERT_WHY_DID_YOU_RENDER__;
      delete React.__IS_WDYR__;
    };
    return React;
  }

  whyDidYouRender.defaultNotifier = defaultNotifier;
  whyDidYouRender.wdyrStore = wdyrStore;
  whyDidYouRender.storeOwnerData = storeOwnerData;
  whyDidYouRender.getWDYRType = getWDYRType;
  whyDidYouRender.getCurrentOwner = getCurrentOwner;
  Object.assign(whyDidYouRender, React__namespace);

  return whyDidYouRender;

}));
//# sourceMappingURL=whyDidYouRender.js.map
